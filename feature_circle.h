#ifndef FEA_CIRCLE
#define FEA_CIRCLE
#include <opencv2/opencv.hpp>
using namespace std;
using namespace cv;
/**
* @brief we use the circle feature to get the score of each step, now we just count circles in every patch as the score. If the score is too low, we will not visit next step. Next step, Combine with the returned score based on other features, we will get an overall score using function isContinue(vector<float> score) 
* 
* @param visited p_visited: visit map
* @param img p_img: score img
* @param direction p_direction:
* @param basePoint p_basePoint:bl point, i do not want to say
* @param params p_params: you can see the description in the reference fucntion
* @param score p_score: return score
*/
void extend_by_circle(Mat& visited, Mat& img,Mat& mask,vector<Point> key_pts, int direction[], vector<int>& params,vector<Point>& centers,float* score,vector<Point>& visit_points, RotatedRect& bounding_r_rect);

/**
* @brief find circles inside the rect or have intersection with the rect.
* 
* @param rect p_rect:...
* @param radius p_radius:...
* @param centers p_centers:...
* @param img p_img:...
* @param belong_rect p_belong_rect:...
*/
void circle_belong_rect( RotatedRect& rect, double radius, vector<Point>& centers,Mat& img,vector<bool>& belong_rect);

/**
* @brief count the points on the bounding of circle. references: https://en.wikipedia.org/wiki/Midpoint_circle_algorithm 
* 
* @param center p_center:...
* @param radius p_radius:...
* @param points p_points:...
*/
void raster_circle(Point center,
         int radius, vector<Point>& points);

/**
* @brief detect circles in the img. first we use adaptive canny to detect the edge, then use the canny threshold in hough circle detection.In the following, we can use the mask area to constraint the circle number.
* 
* @param img p_img:...
* @param params p_params:...
* @param centers p_centers:...
*/
void detection_circles(Mat& img, vector<int> params,vector<Point>& centers);
/**
* @brief find the nearest center of input centers to the given point.
* 
* @param centers p_centers:...
* @param basepoint p_basepoint:...
* @param nearest_point p_nearest_point:...
*/
void find_nearest_center(vector<Point>& centers, Point basepoint,Point* nearest_point);

/**
* @brief this function is used to find all centers that have intersection or inside the input rect.
* 
* @param visited p_visited:...
* @param img p_img:...
* @param r_rect p_r_rect:...
* @param centers p_centers:...
* @param radius p_radius:...
* @param bounding_rect p_bounding_rect:...
* @param remaining_circles p_remaining_circles:...
*/
void find_bounding_rect(Mat& visited,Mat& img,RotatedRect& r_rect,vector<Point>& centers,int radius,RotatedRect& bounding_rect,vector<Point>& remaining_circles);

/**
* @brief count all point inside the rotatedrect
* 
* @param rotated_rect p_rotated_rect:...
* @param rotated_rect_points p_rotated_rect_points:...
*/
void count_points_in_rotated_rect(RotatedRect& rotated_rect,vector<Point>& rotated_rect_points);
#endif
